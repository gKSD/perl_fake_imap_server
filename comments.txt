 Делаем защиту от дурака в римапе, а то дураков развелось в последнее время )

Как я это вижу, описываю примерно:
1) Создаем папочку типа src/rimap/functional_tests, 
в ней пишем сервачек fake_imap.pl (наверное можно на питоне, но лучше на перле - перл нам пригодится в дальнейшей работе). Архитектурно, делаем его в самой простой форковой модели, то есть демон стартует и слушает порт, например, 8899, а как только к нему кто-то коннектится, сервер форкается, и новый коннект обрабатывается уже в чайлде.

2) fake_imap умеет исполнять "сценарии". 
Под сценарием я понимаю последовательность ответов, заранее определенную в каком-то файлике.
Наверное, fake_imap должен также уметь работать в "обычном" режиме.. иными словами, сервер должен поддерживать режимы работы. ?????????

3) Собственно, сам тест - это скрипт, run.pl, который при запуске должен делать примерно следующее:
 - запускает fake_imap.pl, загружает в него сценарий из src/rimap/functional_tests/test1
 - создает сборщик (прямым инсертом в базу rpop.imap) с такими настройками, чтобы он ходил в fake_imap
 - запускает этот сборщик N раз
 - селектит из мескалито получившееся состояние ящика - письма и папки
 - сравнивает с эталонным
 - переходит на следующую итерацию цикла
 - в конце чистит мусор после себя (rpop.imap, rpop.imap_msg)



4) Настройки каждого сценария лежат в src/rimap/functional_tests/test1...testN, в каком-то удобном для чтения виде, например, вот такой json:
fake
{
  1  # при первом запуске отдаем вот такую структуру папок/писем
   {
      inbox: [001, 002, 003, 005]
      test: [10, 11, 12]
   }
  2  # при втором запуске отдаем вот такую структуру папок/писем
   {
      inbox: [002, 005]
      test: [10]
   }
}
Перечисленные папки и uid'ы fake_imap должен отдавать по командам LIST и UID FETCH, именно в перечисленном порядке!
Номера 1, 2 означают, что в рамках одного сценария надо будет запустить сборщик два раза, в первый раз показать ему одни папки, во второй раз - другие.

Плюс, эталонное состояние ящика сборщика, с которым надо будет сравнивать

total
{
   state  # состояние, в котором должен оказаться сборщик, после прогона сценария
   {
      inbox: [002, 005]
      test: [10]
   }
}
Добавка к вышесказанному:
1) сразу поддерживаем дополнительные атрибуты у папок и писем. Например, у писем можно задавать флаги, внутреннюю дату, мб что-то еще, типа

001(seen, answered; 09-Jul-2014 09:21:57 +0000)

У папок тоже есть как минимум флаги:

inbox(hasnochilren, noselect)

Ну и оставить возможность загружать эту инфу без указания флагов, тогда они должны быть дефолтными.

2) Сборщик будет пытаться скачивать письма - командой типа UID FETCH 123 BODY.PEEK[] - надо ему на такую команду отдавать честное письмо. Но в данном случае нам разные письма не нужны, поэтому кладем где-нибудь рядом с настройками файлик - message.eml, в этот файлик пишем минимально возможное rfc822 сообщение, и отдаем его сборщику на любую команду UID FETCH BODY.




В репозитории (ветка rimap) есть файлик, который я использовал, чтобы тестить некоторые кейсы. Он ни разу не автоматизирован, и вообще скорее черновик, но возможно он немного прояснит, чего надо делать - ибо кое-что с помощью него я все таки тестил.

misc/testserver/serv_imap.py


//************************************************************************************************************************************
//************************************************************************************************************************************
МОИ ВОПРОСЫ

1) можно использовать модуль Net::Server::Fork для имап сервера?
2) что ты подразумеваешь под обычным режимом сервера
3) ты написал там, что настройки выглядят так:
    fake
    {
      1  # при первом запуске отдаем вот такую структуру папок/писем
       {
          inbox: [001, 002, 003, 005]
          test: [10, 11, 12]
       }
       2  # при втором запуске отдаем вот такую структуру папок/писем
       {
          inbox: [002, 005]
          test: [10]
       }
    }

    Правильно ли я поняла - случаи 1 и 2 - это различные состояния одного ящика в два разных момента времени?

4) эталонное состояние хранить в отдельном файле ? или в том же файле testN

split

обычный имап сервер отвечает на команду LIST папками юзера, а на команду UID FETCH - письмами из выбранной папки
но у нас имап-сервер не настоящий, его юзеры - виртуальные. папки-письма можно брать, например, из конфига
как в примере
пусть это будет один режим работать
второй режим, например, какой-нить дефолтный, в нем ответы на команды уже сразу захардкожены в коде
и будет выглядеть это как-то так:

if(mode == config)
  loadFolders()
  loadLetters()
  while(1)
     server.waitCommand()
else if(mode == default)
  if(recevedLine == "1 LOGIN")
      send("1 LOGIN OK")
   ...

я думаю как-то так, но не ограничиваю, ты можешь что-то свое придумать и рассказать мне
а, вопросы по пунктам
соответственно, на 2 я вроде ответил

3) правильно. там вроде написано, что тест должен запускаться N раз. соответственно, для 1-ого запуска папки и письма - из 1-ого джейсона, для 2-ого - из 2-ого джейсовна и т.д.
таким образом имитируем ситуацию, что сборщик синхронизировал почту, потом юзер удалил папку на яндексе - соответственно после второго запуска сборщика папка у нас также должна пропатсь локально

вот именно это я и хотела узнать, имитация синхронизации - ок
а еще 1) можно использовать модуль Net::Server::Fork для имап сервера?


я не настолько хорошо знаю перл )
выбирай любые модули по душе
но мне кажется, что fork() можно использовать системный
а для сокеа использовать обычный LWP, например, или любой другой распространенный модуль
в общем, как это будет реализовано, мне не очень важно - бери то что покажется проще


//работа с бд


use DBI;

sub make_connect {
my $host = shift;
my $db_name = shift;
my $user = shift;
my $psw = shift;
my $dbh = DBI->connect("DBI:mysql:database=$db_name;host=$host",$user, $psw);
return $dbh;
}

my $db = make_connect('localhost', 'testdb', 'root', '123456');
$db->do('INSERT into test_table VALUES(?,?)',undef ,2,'345');


$hash_ref = $dbh->selectall_hashref($statement, $key_field);
элементам обращаттся типа того $hash_ref->{key}
hash_ref переменная,
statement запрос вида select * where id=?

key_field это то, что подставится вместо згака вопроса)




//*********************************************************************************************************************************************************************************************
Основные ключи 
if (command == "LOGOUT") CmdLogout();
else if (command == "NOOP") CmdNop();
else if (command == "ID") CmdId();
else if (command == "CAPABILITY") CmdCapability();
else if (command == "SELECT") CmdSelect(false);
else if (command == "EXAMINE") CmdSelect(true);
else if (command == "CREATE") CmdCreate();
else if (command == "DELETE") CmdDelete();
else if (command == "RENAME") CmdRename();
else if (command == "SUBSCRIBE") CmdSubscribe();
else if (command == "UNSUBSCRIBE") CmdUnsubscribe();
else if (command == "LIST") CmdList();
else if (command == "XLIST") CmdList(true);
else if (command == "LSUB") CmdList();
else if (command == "STATUS") CmdStatus();
else if (command == "APPEND") CmdAppend();
if( command != "COPY" && command != "FETCH" && command != "APPEND" )

UID




f (command == "CHECK") CmdCheck();
    else if (command == "CLOSE" || command == "UNSELECT") CmdClose();
        else if (command == "EXPUNGE") CmdExpunge();
            else if (command == "SEARCH") CmdSearch();
                else if (command == "FETCH") CmdFetch();
                ````else if (command == "STORE") CmdStore();
                ````else if (command == "COPY") CmdCopy();
                ````else if (command == "MOVE") CmdMove();
                ````else if (command == "UID") CmdUid();














Флаг 512 - флаг синхронизации

Делаем один файл, который парсится и сервером и скриптом

